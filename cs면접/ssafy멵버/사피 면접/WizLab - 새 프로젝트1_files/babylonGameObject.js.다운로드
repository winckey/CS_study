class BabylonGameObject{constructor(e){const{scene:t,data:s}=e;this.id=s.id,this.name=s.name,this.parentId=s.parentId,this.game=t.game,this.scene=t,this.gameObject=null,this.gizmo=null,this.game.isPlayMode()&&(this.signalQueue=[],this.signalReceiver={},setApiFunctions(this))}static create(e){const{data:t,oncreate:s}=e,{GAMEOBJECT:i}=BabylonConstant;let a;switch(t.type){case i.CAMERA:a=BabylonCamera.create(e);break;case i.SKYBOX:a=BabylonSkybox.create(e);break;case i.LIGHT:a=BabylonLight.create(e);break;case i.MESH:a=BabylonMesh.create(e);break;case i.GUI:a=BabylonGui.create(e);break;case i.TEXTURE_GUI:a=BabylonTextureGui.create(e);break;case i.EMPTY:a=BabylonEmptyObject.create(e);break;default:a=new BabylonGameObject(e)}return s&&a&&s(a),a}static getConstructorWithType(e,t){const{GAMEOBJECT:s}=BabylonConstant;switch(e){case s.CAMERA:return BabylonCamera;case s.SKYBOX:return BabylonSkybox;case s.LIGHT:return BabylonLight;case s.MESH:return BabylonMesh;case s.GUI:return BabylonGui;case s.TEXTURE_GUI:return BabylonTextureGui;default:return null}}static getAvailableGizmoTypes(){return[]}dispose(){this.gameObject.dispose()}getCloneCount(){return this.gameObject.cloneMeshMap?this.gameObject.cloneMeshMap.length:0}onSelected(){this.showEdges(),this.showGizmo()}onDeselected(){this.hideEdges(),this.hideGizmo()}showEdges(){this.game.isEditMode()&&this.gameObject.enableEdgesRendering&&(this.gameObject.enableEdgesRendering(),this.gameObject.edgesColor=new BABYLON.Color4(0,0,0,.6))}hideEdges(){this.gameObject.disableEdgesRendering&&this.gameObject.disableEdgesRendering()}showGizmo(){if(!this.game.isEditMode())return;const e=this.getCurrentGizmoType();if(!this.checkGizmoTypeAvailable(e))return;const t=this.getGizmoConstructor(e);if(!t)return;const s=new t(this.scene.gizmoLayer);s.onDragStartObservable.add(this.onGizmoDragStart.bind(this)),s.onDragEndObservable.add(this.onGizmoDragEnd.bind(this)),s.attachedMesh=this.gameObject,this.gizmo=s}getCurrentGizmoType(){return this.game.getCurrentGizmoType()}checkGizmoTypeAvailable(e){return this.constructor.getAvailableGizmoTypes().includes(e)}getGizmoConstructor(e){switch(e){case"scale":return BABYLON.ScaleGizmo;case"rotation":return BABYLON.RotationGizmo;case"position":return BABYLON.PositionGizmo;default:return null}}hideGizmo(){this.gizmo&&(this.gizmo.dispose(),this.gizmo=void 0)}onChangeCurrentGizmoType(e){this.gizmo&&this.hideGizmo(),this.showGizmo()}onGizmoDragStart(){switch(this.getCurrentGizmoType()){case"scale":this.prevScaling=this.gameObject.scaling.clone();break;case"rotation":this.prevRotation=this.gameObject.rotation.clone();break;case"position":this.prevPosition=this.gameObject.position.clone()}}onGizmoDragEnd(){const e=this.getCurrentGizmoType();switch(e){case"scale":this.onChangeTransform(e,this.gameObject.scaling);break;case"rotation":this.onChangeTransform(e,this.gameObject.rotation);break;case"position":this.onChangeTransform(e,this.gameObject.position)}}onChangeTransform(e,t){const{x:s,y:i,z:a}=t,o="rotation"===e?this.trimRotation:this.trimFloat,n={x:o(s),y:o(i),z:o(a)},r={id:this.id,sceneId:this.scene.id,propertyId:e,value:n};this.game.triggerListener("gameObjectPropertyChange",r)}trimFloat(e){return parseFloat(parseFloat(e).toFixed(5))}trimRotation(e){return parseInt(BABYLON.Tools.ToDegrees(e))}setProperty(e,t){let s;switch(e){case BabylonConstant.PROPERTY_ID.PARENT_ID:s="setParent";break;default:s="set"+e[0].toUpperCase()+e.slice(1,e.length)}const i=this[s];i&&i.bind(this)(t)}setPosition(e){this.gameObject.position.x=e.x,this.gameObject.position.y=e.y,this.gameObject.position.z=e.z}setRotation(e){this.gameObject.rotation.x=BABYLON.Tools.ToRadians(e.x),this.gameObject.rotation.y=BABYLON.Tools.ToRadians(e.y),this.gameObject.rotation.z=BABYLON.Tools.ToRadians(e.z)}setScale(e){this.gameObject.scaling.x=e.x,this.gameObject.scaling.y=e.y,this.gameObject.scaling.z=e.z}setDirection(e){this.gameObject.direction.x=e.x,this.gameObject.direction.y=e.y,this.gameObject.direction.z=e.z}setParent(e){if(this.gameObject)if(e){const t=this.scene.getGameObject(e);t&&(this.gameObject.parent=t.gameObject,this.parentId=e)}else this.gameObject.parent=null,this.parentId=null}onAllGameObjectsAdded(){this.setParent(this.parentId)}resolveSignal(e){e in this.signalReceiver&&this.signalReceiver[e]()}runUserScript=function(){const e=userScripts[this.scene.id][this.id];"function"==typeof e&&e(getApis(this));const t=this.signalQueue.length;if(t>0)for(let e=0;e<t;e++)this.resolveSignal(this.signalQueue.pop())}}class BabylonMesh extends BabylonGameObject{static create(e){const{data:t}=e,s=BabylonConstant.MESH;let i;switch(t.subtype){case s.GROUND:i=BabylonGround.create(e);break;case s.BOX:i=BabylonBox.create(e);break;case s.SPHERE:i=BabylonSphere.create(e);break;case s.OBJ:return i=BabylonOBJ.create(e),i;default:return}return i.init(t),i}init(e){this.setPosition(e.position),this.setRotation(e.rotation),this.setScale(e.scale),this.setSpeed()}static getAvailableGizmoTypes(){return[BabylonConstant.GIZMO.POSITION,BabylonConstant.GIZMO.ROTATION,BabylonConstant.GIZMO.SCALE]}addOnClickListener(e){this.gameObject.isPickable=!0,this.gameObject.actionManager||(this.gameObject.actionManager=new BABYLON.ActionManager(this.scene.scene)),this.gameObject.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger,e))}getClone(){const e=`clone${this.getCloneCount()+1}`,t=`${this.id}_${e}`,s=`${this.name}_${e}_${(new Date).getTime()}`,i=this.parentId?this.scene.getGameObject(this.parentId):null,a=i?i.gameObject:null,o=this.gameObject.clone("name",a),n=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return n.id=t,n.name=s,n.gameObject=o,this.scene.addGameObject(n,!0),n}setBillboardMode(e){this.gameObject.billboardMode=e}setPhysics(e,t,s){this.scene.isPhysicsEnabled()&&(this.gameObject.physicsImpostor||(this.gameObject.physicsImpostor=new BABYLON.PhysicsImpostor(this.gameObject,this.constructor.getPhysicsImpostorType(),{},this.scene.scene)),void 0!==e&&this.setPhysicsParam("mass",e),void 0!==t&&this.setPhysicsParam("restitution",t),void 0!==s&&this.setPhysicsParam("friction",s))}resetPhysicsParams(){const e=this.gameObject.physicsImpostor;e&&(this.prevPhysicsParams={mass:e.mass,restitution:e.restitution,friction:e.friction},this.setPhysicsParam("mass",0),this.setPhysicsParam("restitution",0),this.setPhysicsParam("friction",0))}restorePhysicsParams(){if(!this.gameObject.physicsImpostor||!this.prevPhysicsParams)return;const{mass:e,restitution:t,friction:s}=this.prevPhysicsParams;this.setPhysicsParam("mass",e),this.setPhysicsParam("restitution",t),this.setPhysicsParam("friction",s)}static getPhysicsImpostorType(){return BABYLON.PhysicsImpostor.BoxImpostor}setPhysicsParam(e,t){const s=this.gameObject.physicsImpostor;s&&s.setParam(e,t)}getPhysicsParam(e){const t=this.gameObject.physicsImpostor;if(t)return t.getParam(e)}registerOnPhysicsCollide(e,t){if(!this.gameObject.physicsImpostor)return!1;const s=[];return e.forEach((e=>{e.gameObject.physicsImpostor&&s.push(e.gameObject.physicsImpostor)})),0!==s.length&&(this.gameObject.physicsImpostor.registerOnPhysicsCollide(s,t),!0)}unregisterOnPhysicsCollide(e,t){if(!this.gameObject.physicsImpostor)return;const s=[];e.forEach((e=>{e.gameObject.physicsImpostor&&s.push(e.gameObject.physicsImpostor)})),s.length>0&&this.gameObject.physicsImpostor.unregisterOnPhysicsCollide(s,t)}setSpeed(e,t,s){this.speed||(this.speed=new BABYLON.Vector3(100,100,100)),void 0!==e&&(this.speed.x=e),void 0!==t&&(this.speed.y=t),void 0!==s&&(this.speed.z=s)}getSpeed(e){return e?this.speed[e]:this.speed}setVelocity(e,t){this.gameObject.physicsImpostor&&(this.velocity||(this.velocity=new BABYLON.Vector3(0,0,0)),this.velocity[e]=t,this.gameObject.physicsImpostor.setLinearVelocity(this.velocity))}getVelocity(e){return this.velocity?this.velocity[e]:0}setAngularVelocity(e,t){this.gameObject.physicsImpostor&&(this.angularVelocity||(this.angularVelocity=new BABYLON.Vector3(0,0,0)),this.angularVelocity[e]=t,this.gameObject.physicsImpostor.setAngularVelocity(this.angularVelocity))}getAngularVelocity(e){return this.angularVelocity?this.angularVelocity[e]:0}setControlOption(e,t){this.controlOptions||(this.controlOptions={}),this.controlOptions[e]=t}attachDefaultControl(e){e?(this.gameObject.physicsImpostor||this.setPhysics(0,0,0),this.controlOptions&&this.controlOptions.rotationSpeed||this.setControlOption("rotationSpeed",1),this.controlOptions.maxJump||this.setControlOption("maxJump",1),this.transformNode=new BABYLON.TransformNode,this.defaultControlObserver=this.scene.addBeforeRenderObservable((()=>{this.defaultControl(),this.transformNode.position=this.gameObject.position})),this.checkAndUpdateCameraTarget(!0)):this.defaultControlObserver&&(this.scene.removeBeforeRenderObservable(this.defaultControlObserver),this.defaultControlObserver=null,this.checkAndUpdateCameraTarget(!1),this.transformNode.dispose(),this.transformNode=null)}defaultControl=()=>{const{keyCodeInputMap:e}=this.scene,t=this.scene.scene.getAnimationRatio(),s=this.transformNode.getDirection(BABYLON.Vector3.Forward());let i=0;if((e[87]||e[38])&&(i=.06*t*(this.speed.z/100)),(e[83]||e[40])&&(i=-.06*t*(this.speed.z/100)),(e[65]||e[37])&&(this.transformNode.rotate(BABYLON.Axis.Y,-.03*t*this.controlOptions.rotationSpeed),this.gameObject.rotate(BABYLON.Axis.Y,-.03*t*this.controlOptions.rotationSpeed)),(e[68]||e[39])&&(this.transformNode.rotate(BABYLON.Axis.Y,.03*t*this.controlOptions.rotationSpeed),this.gameObject.rotate(BABYLON.Axis.Y,.03*t*this.controlOptions.rotationSpeed)),this.gameObject.moveWithCollisions(s.scale(i)),this.jumpVectorY||(this.jumpVectorY=0),e[32]?(this.jumpVectorY+=.03*t,this.jumpVectorY>.12*t*this.controlOptions.maxJump&&(this.jumpVectorY=.12*t*this.controlOptions.maxJump)):(this.jumpVectorY-=.03*t,this.jumpVectorY<0&&(this.jumpVectorY=0)),0!==this.jumpVectorY){let e=new BABYLON.Vector3(0,0,0);e.y=this.jumpVectorY,this.gameObject.moveWithCollisions(e)}};checkAndUpdateCameraTarget(e){const t=this.scene.scene.activeCamera.lockedTarget;t&&(e&&t===this.gameObject?this.scene.scene.activeCamera.lockedTarget=this.transformNode:e||t!==this.transformNode||(this.scene.scene.activeCamera.lockedTarget=this.gameObject))}}class BabylonBox extends BabylonMesh{static create(e){const{scene:t,data:s}=e,i=new BabylonBox(e),a=BABYLON.MeshBuilder.CreateBox(s.id,{},t.scene);return i.gameObject=a,i}}class BabylonGround extends BabylonMesh{static create(e){const{scene:t,data:s}=e,i=new BabylonGround(e),a=BABYLON.MeshBuilder.CreateGround(s.id,{},t.scene);return i.gameObject=a,i}onAllGameObjectsAdded(){super.onAllGameObjectsAdded(),this.gameObject.receiveShadows=!0}static getPhysicsImpostorType(){return BABYLON.PhysicsImpostor.BoxImpostor}}class BabylonSphere extends BabylonMesh{static create(e){const{scene:t,data:s}=e,i=new BabylonSphere(e),a=BABYLON.MeshBuilder.CreateSphere(s.id,{},t.scene);i.gameObject=a;var o=new BABYLON.StandardMaterial("mat",t.scene);return o.diffuseColor=new BABYLON.Color3.Random,a.material=o,i}static getPhysicsImpostorType(){return BABYLON.PhysicsImpostor.SphereImpostor}}class BabylonOBJ extends BabylonMesh{static create(e){const{scene:t,data:s,oncreate:i}=e,a=new BabylonOBJ(e);a.path=a.getUrl(s.path),a.filename=s.filename;const o=t.addMeshTask("objTask","",a.path,s.filename);return s.filename.includes("Hex10")&&(s.texture=void 0),o.onSuccess=e=>{const o=a.getMeshFromTask(e),n=o.material;n&&s.texture&&(a.texture=new BABYLON.Texture(a.getUrl(s.texture),t.scene),n.diffuseTexture=a.texture,n.specularTexture=a.texture,n.emissiveTexture=a.texture,n.ambientTexture=a.texture),a.gameObject=o,a.gameObject.id=s.id,a.gameObject.name=s.name,a.gameObject.receiveShadows=!0,a.init(s),i(a)},o.onError=(e,t,s)=>{console.log(111,"meshTask error",t,s),e.loadedMeshes&&e.loadedMeshes.forEach((e=>{e.dispose()}))},null}getUrl(e){let t=e;return this.game.getBaseUrl()&&(t=`${this.game.getBaseUrl()}${e.substring(1)}`),t}getMeshFromTask(e,t=!1){const s=e.loadedMeshes;if(1===s.length){const e=s[0];if(t)e.material=this.gameObject.material;else if(!e.material){const t=new BABYLON.StandardMaterial(`${this.id}_mat`,this.scene.scene);t.diffuseColor=new BABYLON.Color3.Random,t.emissiveColor=new BABYLON.Color3.Random,e.material=t}return e}{const e=BABYLON.Mesh.MergeMeshes(s,!0,!0,void 0,!0);let i=null;if(t?i=this.gameObject.material:(i=new BABYLON.MultiMaterial(`${this.id}_mat`,this.scene.scene),s.forEach((e=>{i.subMaterials.push(e.material)}))),e.material=i,i instanceof BABYLON.MultiMaterial){const t=e.subMeshes;for(let e=0;e<t.length;e++)t[e].materialIndex=e}return e}}async getClone(){const e=`clone${this.getCloneCount()+1}`,t=`${this.id}_${e}`,s=this.name,i=await this.getClonedObj(this,t,s);if(!i)return;const a=Object.assign(Object.create(Object.getPrototypeOf(this)),this);a.id=t,a.name=s,a.gameObject=i,this.parentId&&a.setParent(this.parentId),a.setPosition(this.gameObject.position),a.setRotation(this.gameObject.rotation),a.setScale(this.gameObject.scaling);const o=this.gameObject.physicsImpostor;return o&&a.setPhysics(o.mass,o.restitution,o.friction),this.scene.addGameObject(a),a}getClonedObj(e,t,s){return new Promise((function(i){e.path&&e.filename||i(null);const a=e.scene.addMeshTask("objTask","",e.path,e.filename);a.onSuccess=a=>{const o=e.getMeshFromTask(a,!0);o.id=t,o.name=s,o.receiveShadows=e.gameObject.receiveShadows,o.material&&e.texture&&(o.material.diffuseTexture=e.texture,o.material.specularTexture=e.texture,o.material.emissiveTexture=e.texture,o.material.ambientTexture=e.texture),i(o)},a.onError=(e,t,s)=>{console.log(111,"meshTask error",t,s),i(null)},e.scene.loadAssetsManager()}))}}class BabylonGui extends BabylonGameObject{constructor(e){super(e)}static create(e){const{data:t}=e;let s;const i=BabylonConstant.GUI;switch(t.subtype){case i.BUTTON:s=BabylonGuiButton.create(e);break;case i.TEXT:s=BabylonGuiText.create(e)}return s.commontInit(t),s}commontInit(e){this.gameObject.color="white",this.gameObject.background="black",this.gameObject.horizontalAlignment=BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT,this.gameObject.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP,this.setWidth(e.width),this.setHeight(e.height),this.setFontSize(e.fontSize),this.setPosition(e.position),this.setRotation(e.rotation),this.setCornerRadius(e.cornerRadius),this.game.isEditMode()&&(this.setPointerPicker(),this.setEngineResizeObservable(),this.setDraggable())}dispose(){this.scene.removeGUI(this),super.dispose()}addOnClickListener(e){this.gameObject.isPointerBlocker=!0,this.gameObject.onPointerClickObservable.add(e)}setPointerPicker(){this.gameObject.isPointerBlocker=!0,this.gameObject.onPointerDownObservable.add((()=>{this.scene.onPointerPickGameObject(this)}))}setEngineResizeObservable(){this.game.engine.onResizeObservable.add((()=>{this.engineResizeTimeout&&(clearTimeout(this.engineResizeTimeout),this.engineResizeTimeout=void 0),this.engineResizeTimeout=setTimeout(this.updateGUIProperties.bind(this),100)}))}setDraggable(){this.gameObject.onPointerDownObservable.add((e=>{this.dragStartPointerPoint=new BABYLON.Vector2(e.x,e.y),this.dragStartPoint=new BABYLON.Vector2(parseFloat(this.gameObject.left),parseFloat(this.gameObject.top)),this.isDragging=!0})),this.gameObject.onPointerUpObservable.add((()=>{const e={x:parseFloat(this.gameObject.left),y:parseFloat(this.gameObject.top)},t=this.convertToGUIPosition(e),s={id:this.id,sceneId:this.scene.id,propertyId:"position",value:t};this.game.triggerListener("gameObjectPropertyChange",s),this.dragStartPointerPoint=null,this.dragStartPoint=null,this.isDragging=!1})),this.gameObject.onPointerMoveObservable.add((e=>{if(this.isDragging){const t=this.dragStartPointerPoint.subtract(new BABYLON.Vector2(e.x,e.y));this.gameObject.left=this.dragStartPoint.x-t.x,this.gameObject.top=this.dragStartPoint.y-t.y}})),this.scene.guiEditorContainer.onPointerMoveObservable.add((e=>{if(this.isDragging){const t=this.dragStartPointerPoint.subtract(new BABYLON.Vector2(e.x,e.y));this.gameObject.left=this.dragStartPoint.x-t.x,this.gameObject.top=this.dragStartPoint.y-t.y}}))}setPosition(e){const t=this.convertToTexturePosition(e);this.gameObject.left=t.x,this.gameObject.top=t.y,this.guiPosition=e}setRotation(e){this.gameObject.rotation=BABYLON.Tools.ToRadians(e.x)}setWidth(e){this.gameObject.width=this.converToTextureWidth(e)+"px",this.guiWidth=e}setHeight(e){this.gameObject.height=this.converToTextureHeight(e)+"px",this.guiHeight=e}setFontSize(e){this.gameObject.fontSize=this.converToTextureFontSize(e),this.guiFontSize=e}setCornerRadius(e){this.gameObject.cornerRadius=this.converToTextureCornerRadius(e),this.guiCornerRadius=e}setText(e){this.gameObject.text=e}setGuiTextColor(e){this.gameObject.color=e}getGuiTextColor(){return this.gameObject.color}setGuiBackgroundColor(e){this.gameObject.background=e}updateGUIProperties(){this.updatePosition(),this.updateWidth(),this.updateHeight(),this.updateFontSize(),this.updateCornerRadius()}updatePosition(){this.setPosition(this.guiPosition)}updateWidth(){this.setWidth(this.guiWidth)}updateHeight(){this.setHeight(this.guiHeight)}updateFontSize(){this.setFontSize(this.guiFontSize)}updateCornerRadius(){this.setCornerRadius(this.guiCornerRadius)}converToTextureWidth(e){return e/1280*this.scene.getGUISizeInPixels().width}converToTextureHeight(e){return e/720*this.scene.getGUISizeInPixels().height}converToTextureFontSize(e){return e/720*this.scene.getGUISizeInPixels().height}converToTextureCornerRadius(e){return e/720*this.scene.getGUISizeInPixels().height}convertToTexturePosition(e){const{width:t,height:s}=this.scene.getGUISizeInPixels();return{x:e.x/1280*t,y:e.y/720*s}}convertToGUIPosition(e){const{width:t,height:s}=this.scene.getGUISizeInPixels(),i=e.x/t*1280,a=e.y/s*720;return{x:parseFloat(parseFloat(i).toFixed(1)),y:parseFloat(parseFloat(a).toFixed(1))}}}class BabylonGuiButton extends BabylonGui{static create(e){const{data:t}=e,s=new BabylonGuiButton(e),i=BABYLON.GUI.Button.CreateSimpleButton(t.id,t.text);return s.gameObject=i,s}setText(e){this.gameObject.textBlock.text=e}}class BabylonGuiText extends BabylonGui{static create(e){const{data:t}=e,s=new BabylonGuiText(e),i=new BABYLON.GUI.TextBlock;return i.text=t.text,s.gameObject=i,s}}class BabylonTextureGui extends BabylonGameObject{constructor(e){super(e),this.gui=null}static create(e){const{scene:t,data:s}=e,i=new BabylonTextureGui(e);let a;const o=BabylonConstant.GUI;switch(s.subtype){case o.BUTTON:a=BABYLON.GUI.Button.CreateSimpleButton(s.id,s.text);break;case o.TEXT:a=new BABYLON.GUI.TextBlock(s.id,s.text),a.fontSize=s.fontSize}return a.width=s.width,a.height=s.height,a.color="white",a.cornerRadius=s.cornerRadius,a.background=s.background,a.resizeToFit=!0,a.thickness=0,i.getAdvancedTexture(t).addControl(a),i.gui=a,i.setPosition(s.position),i.setRotation(s.rotation),i.setScale(s.scale),i}getAdvancedTexture(e){return this.gameObject||(this.gameObject=BABYLON.Mesh.CreatePlane(this.id,4,e.scene),this.gameObject.isPickable=this.game.isEditMode()),BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(this.gameObject)}setText(e){"TextBlock"!==this.gui.typeName?this.gui.textBlock.text=e:this.gui.text=e}setGuiTextColor(e){"TextBlock"!==this.gui.typeName?this.gui.textBlock.color=e:this.gui.color=e}getGuiTextColor(){return"TextBlock"===this.gui.typeName?this.gui.color:this.gui.textBlock.color}setGuiBackgroundColor(e){"TextBlock"!==this.gui.typeName?this.gui.textBlock.background=e:this.gui.background=e}setBillboardMode(e){this.gameObject.billboardMode=e}addOnClickListener(e){this.gameObject.isPickable=!0,this.gui.isPointerBlocker=!0,this.gui.onPointerClickObservable.add(e)}getClone(){const e=`clone${this.getCloneCount()+1}`,t=`${this.id}_${e}`,s=`${this.name}_${e}_${(new Date).getTime()}`,i=this.parentId?this.scene.getGameObject(this.parentId):null,a=i?i.gameObject:null,o=this.gameObject.clone("name",a),n=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return n.id=t,n.name=s,n.gameObject=o,this.scene.addGameObject(n,!0),n}static getAvailableGizmoTypes(){return[BabylonConstant.GIZMO.POSITION,BabylonConstant.GIZMO.ROTATION,BabylonConstant.GIZMO.SCALE]}}class BabylonCamera extends BabylonGameObject{constructor(e){super(e),this.isActiveCamera=!1}static create(e){const{data:t}=e;let s;const i=BabylonConstant.CAMERA;switch(t.subtype){case i.UNIVERSAL:s=BabylonUniversalCamera.create(e);break;case i.ARCROTATE:s=BabylonArcRotateCamera.create(e);break;case i.FOLLOW:s=BabylonFollowCamera.create(e);break;default:return}return s.setIsActiveCamera(t.isActiveCamera),s}setIsActiveCamera(e){this.isActiveCamera=e,this.game.isPlayMode()&&e&&(this.gameObject.attachControl(this.game.canvas,!0),this.scene.scene.activeCamera=this.gameObject)}static getAvailableGizmoTypes(){return[BabylonConstant.GIZMO.POSITION,BabylonConstant.GIZMO.ROTATION]}}class BabylonUniversalCamera extends BabylonCamera{static create(e){const{scene:t,data:s}=e,i=new BabylonUniversalCamera(e);return i.gameObject=new BABYLON.UniversalCamera(s.id,new BABYLON.Vector3(s.position.x,s.position.y,s.position.z),t.scene),i.setRotation(s.rotation),i}}class BabylonArcRotateCamera extends BabylonCamera{static create(e){const{scene:t,data:s}=e,i=new BabylonArcRotateCamera(e);return i.gameObject=new BABYLON.ArcRotateCamera(s.id,0,0,10,new BABYLON.Vector3(0,0,0),t.scene),i.setPosition(s.position),i}setPosition(e){this.gameObject.setPosition(new BABYLON.Vector3(e.x,e.y,e.z))}}class BabylonFollowCamera extends BabylonCamera{static create(e){const{scene:t,data:s}=e,i=new BabylonFollowCamera(e),a=new BABYLON.FollowCamera(s.id,new BABYLON.Vector3(s.position.x,s.position.y,s.position.z),t.scene);return a.lowerHeightOffsetLimit=6,a.heightOffset=6,a.upperHeightOffsetLimit=6,a.lowerRadiusLimit=12,a.radius=12,a.upperRadiusLimit=12,a.lowerRotationOffsetLimit=165,a.rotationOffset=180,a.upperRotationOffsetLimit=195,i.targetId=s.targetId,i.gameObject=a,i.setRotation(s.rotation),i}onAllGameObjectsAdded(){super.onAllGameObjectsAdded(),this.game.isPlayMode()&&this.updateTarget()}updateTarget(){const e=this.gameObject,t=this.scene.getGameObject(this.targetId);t&&(e.lockedTarget=t.gameObject)}}class BabylonLight extends BabylonGameObject{static create(e){const{data:t}=e;let s;const i=BabylonConstant.LIGHT;switch(t.subtype){case i.POINT:s=BabylonPointLight.create(e);break;case i.SPOT:s=BabylonSpotLight.create(e);break;case i.HEMISPHERIC:s=BabylonHemisphericLight.create(e);break;case i.DIRECTIONAL:default:s=BabylonDirectionalLight.create(e)}return s}setIntensity(e){this.gameObject.intensity=e}setRange(e){this.gameObject.range=e}}class BabylonPointLight extends BabylonLight{static create(e){const{scene:t,data:s}=e,{position:i,intensity:a,range:o}=s,n=new BABYLON.PointLight(s.id,new BABYLON.Vector3(i.x,i.y,i.z),t.scene);n.intensity=a,n.range=o;const r=new BabylonPointLight(e);return r.gameObject=n,r}static getAvailableGizmoTypes(){return[BabylonConstant.GIZMO.POSITION]}}class BabylonSpotLight extends BabylonLight{static create(e){const{scene:t,data:s}=e,{position:i,direction:a,intensity:o,range:n}=s,r=new BABYLON.SpotLight(s.id,new BABYLON.Vector3(i.x,i.y,i.z),new BABYLON.Vector3(a.x,a.y,a.z),Math.PI/2,10,t.scene);r.intensity=o,r.range=n;const c=new BabylonSpotLight(e);return c.gameObject=r,c}static getAvailableGizmoTypes(){return[BabylonConstant.GIZMO.POSITION]}}class BabylonDirectionalLight extends BabylonLight{static create(e){const{scene:t,data:s}=e,{x:i,y:a,z:o}=s.direction,n=new BABYLON.Vector3(i,a,o),r=new BABYLON.DirectionalLight(s.id,n,t.scene),c=new BabylonDirectionalLight(e);return c.gameObject=r,c}}class BabylonHemisphericLight extends BabylonLight{static create(e){const{scene:t,data:s}=e,{x:i,y:a,z:o}=s.direction,n=new BABYLON.Vector3(i,a,o),r=new BABYLON.HemisphericLight(s.id,n,t.scene),c=new BabylonHemisphericLight(e);return c.gameObject=r,c}}class BabylonSkybox extends BabylonGameObject{constructor(e){super(e),this.defaultSkyboxSize=1e3}static create(e){const{scene:t,data:s}=e,i=new BabylonSkybox(e),a=BABYLON.MeshBuilder.CreateBox(s.id,{size:s.size},i.scene.scene);a.infiniteDistance=!0;const o=new BABYLON.StandardMaterial(i.id,i.scene.scene);return o.backFaceCulling=!1,o.reflectionTexture=new BABYLON.CubeTexture(i.getUrl(s.texture),i.scene.scene),o.reflectionTexture.coordinatesMode=BABYLON.Texture.SKYBOX_MODE,o.diffuseColor=new BABYLON.Color3(0,0,0),o.specularColor=new BABYLON.Color3(0,0,0),a.material=o,i.gameObject=a,i}getUrl(e){let t=e;return this.game.getBaseUrl()&&(t=`${this.game.getBaseUrl()}${e.substring(1)}`),t}setSize(e){const t=parseFloat(e)/this.defaultSkyboxSize;this.gameObject.scaling.x=t,this.gameObject.scaling.y=t,this.gameObject.scaling.z=t}}class BabylonEmptyObject extends BabylonGameObject{static create(e){const{data:t}=e,s=new BabylonEmptyObject(e),i=new BABYLON.TransformNode(t.id,s.scene.scene);return s.gameObject=i,s.init(t),s}init(e){this.setPosition(e.position),this.setRotation(e.rotation),this.setScale(e.scale)}static getAvailableGizmoTypes(){return[BabylonConstant.GIZMO.POSITION,BabylonConstant.GIZMO.ROTATION,BabylonConstant.GIZMO.SCALE]}}window.BabylonGameObject=BabylonGameObject;