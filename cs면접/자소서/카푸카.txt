카프카 클라이언트
카프카 커넥트 : 
카프카 커넥트는 아파치 카프카의 오픈소스 프로젝트 중 하나로, 카프카와 외부 시스템(DB 등) 간의 파이프라인 구성을 쉽게 해주는 프레임워크이다. 
https://minkwon4.tistory.com/319



토픽생성
kafka-topics.bat --bootstrap-server localhost:9092 --list
kafka-topics.bat --bootstrap-server localhost:9092 --create --topic quickstart-events --partitions 1
9092 => 카푸카 9092 서버에 토픽을 생성하겠다
파티션 => 클러스터링 환경에서 얼마나 나누 겠느냐를 물어보는 옵션 
(주의 생성시 server.propertis 파일에서 해당포트를 허용하는 설정을입력 (주석해제) 해주어야함 / 
안하면 : could not be established. Broker may not be available 에러 발생 )

리스트 확인 
kafka-topics.bat --bootstrap-server localhost:9092 --list

-. 카프카에 대해 설명해주세요.
= 분산 이벤트 스트리밍 플랫폼 시스템 규모의 확장으로 Point to point 통신 방식에서 복잡도 증가와 관리의 어려움으로 인해
e to e 를 제공하는 서비스 개발을 위해 개발됨

- 주키퍼(Zookeeper) : 아파치 프로젝트 애플리케이션으로 카프카의 메타데이터 관리 및 브로커의 정상상태 점검 을 담당 합니다. => 크라프트로 대체중
- 카프카(Kafka) or 카프카 클러스터(Kafka cluster) : 아파치 프로젝트 애플리케이션으로 여러 대의 브로커를 구성한 클러스터를 의미 합니다.
- 브로커(broker) : 카프카 애플리케이션이 설치된 서버 또는 노드를 의미 합니다. => 복제서버 = 카프카 한개의 서버
- 프로듀서(producer) : 카프카로 메시지를 보내는 역할을 하는 클라이언트로 총칭합니다.
- 컨슈머(consumer) : 카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트를 총칭합니다. = 두개 합쳐서 카푸카 클라이언트 


- 토픽(topic) : 카프카는 메시지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 고유합니다.
- 파티션(partition) : 병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 의미합니다 = > 병렬동작을 위한 분할
병렬 동작 => 라운드 로빈 속도는 빠를수 있어도 순서를 보장하지는 않음 

- 세그먼트(segment) : 프로듀서가 전송한 실제 메시지가 중개인의 로컬 디스크에 저장되는 파일을 말합니다. = > 여러 메시지가 모여서 세그먼트를 이룸
- 메시지(message) 또는 레코드(record): 프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각을 말합니다.
ex) 카프카 클러스팅, 프로듀서, 컨슈머에 대해 설명, 브로커 확장, 토픽 어떤식으로 설계하는지 etc...

멀티 스레드 컨슈머
카프카는 처리량을 늘리기 위해 파티션과 컨슈머 개수를 늘려서 운영할 수 있다. 
파티션을 여러개로 운영하는 경우 데이터를 병렬처리하기 위해서 파티션 개수와 컨슈머 개수를 동일하게 맞추는 것이 가장 좋은 방법이다. 

-. 카프카 어느 부분에 적용해봤는지?
=> MSA 비동기 통신에 이용하였다 프로튜서와 컨슈머를 구현하여 메시지 송수신에 이용 (메시지 큐 메시지 브로커)


5. 브로커가 다운되면 전체 시스템에 어떤 영향을 주는가? 이 문제를 해결하려면 어떻게 해야하나?
각 파티션 그룹은 리더를 가지고있고 리더가 다른 파티션들의 복제 상태를 점검한다. 이때 장에 발생시 해당 파티션을
isr 그룹에서 퇴출 시킨다. ( 브로커는 복제를 위함이기 때문에 컨슈머에는 영향 x )
브로커에 장애 발생브로커 다운시 쥬키퍼가 리더 브로커에게 알려 . 컨트롤러가 새로운 리더지정
가능한 브로커가 없다면 가장 빨리 복구 되는 브로커를 리더로 지정

6. 오토커밋이 무엇이며 어떻게 설정하는것이 좋은가?
컨슈머 장애시 해당 컨슈머와 연결된 파티션을 사용하지 못함 이를 위해 컨슈머 상태를 체크하고 리밸런싱함(연결을 다 끊어 버림)
이과정에서 읽은 메시지를 다시 읽을수 있음(커밋을 하지 못했기 때문에 )
오토커밋을 이를 방지하기 위해 자신이 어디 까지 읽었는지 처리중에도 커밋하는 기능
너무 짧게 하면 다처리하지 못했는데 넘어 갈수 있다


스프링
객체지향이란?
프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.
객체지향 프로그래밍의 장점
코드 재사용이 용이 => 남이 만든 클래스를 가져와서 사용가능
유지보수가 쉬움 => 절차지향 프로그래밍은 일일이 찾아 수정해야하는 반면에 해당하는 부분만 수정하면됨
대형 프로젝트에 적합 => 클래스 단위로 모듈화 시켜서 개발가능
객체 지향적 설계 원칙
SRP(Single Responsibility Principle) : 단일 책임 원칙 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
OCP(Open-Closed Principle) : 개방-폐쇄 원칙 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
ISP(Interface Segregation Principle) : 인터페이스 분리 원칙 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
DIP(Dependency Inversion Prinsiple) : 의존 역전 원칙 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
객체지향 프로그래밍 키워드
추상화 : 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것
캡슐화 : 기능과 특성의 모음을 "클래스"라는 "캡슐"에 넣어서 분류해서 넣는 이 캡슐화다.
상속 :상속은 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다. 다중 상속은 불가하다.
다형성 : 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.즉, 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.
오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것.
오버로딩 : 같은 이름의 함수를 여러 개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.
제네릭이 무엇인가요?
제네릭(Generic)은 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다.
컬렉션 클래스에서 제네릭을 사용하는 이유를 설명하세요
컬렉션 클래스에 저장되는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일 타임에 잡아 낼 수 있어서 사용합니다.
데드락이 무엇이고, 해결방법에 대해 설명해보세요
둘 이상의 스레드가 lock을 획득하기 위해 기다리는데, 이 lock을 잡고 있는 스레드도 똑같이 다른 lock을 기다리면서 서로 블락상태에 놓이는 것을 말한다
우선순위를 선정해 자원을 선점하도록 하는 것과 공유 불가능한 상호 배제 조건을 제거하는 것이 있다.
JVM이 하는 역할이 무엇인가요?
자바 컴파일러가 .java 파일을 컴파일 하면, .class라는 자바 바이트코드로 변환시켜줍니다. 이때 바이트 코드가 기계어가 아니기 때문에 운영체제에서 바로 실행을 못하는데 이때 운영체제가 이해할 수 있도록 해석해주는 것이 JVM입니다.
컴파일 -> 바이트 코드 -> 기계어 이런식으로 중간에 바이트 코드 과정이 있기 때문에 속도와 메모리에서 단점이 될 수 있다.
JVM을 사용하면 운영체제에 상관없이 같은 코드를 사용할 수 있습니다.
스프링에서 AOP가 뭔가요?
AOP는 관점 지향 프로그래밍의 약자인데요 기존의 OOP에서 기능별로 클래스를 분리했음에도 불구하고, 공통적으로 반복되는 중복코드가 발생하는데 이를 해결할 수 있도록 실행시 비즈니스 로직의 앞과 뒤에서 원하는 지점에 해당 공통 관심사를 수행할 수 있게 한다.
스프링 DI에 대해 아는대로 말씀해주세요
DI는 의존성 주입의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 스프링의 IOC 컨테이너의 구체적 구현 방식을 말한다.
필드 주입, setter 주입, 생성자 주입 3가지가 있다.
개발코드 부분에서 객체를 생성하는 것이 아니라, 데이터 주입만 담당하는 별도의 공간에서 객체를 생성하고, 데이터 간의 의존성을 주입해 개발코드에서 가져다 쓰면서 의존성을 줄인다.
IOC가 무엇인가요?
IOC는 제어의 역전으로 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너가 대신 관리해주는 것을 말한다. (프레임워크)
IOC 컨테이너는 DI를 통해 주입시킨다.
인스턴스의 생성의 제어를 서블릿과 같은 bean을 관리해주는 컨테이너가 관리합니다.
Bean이란?
spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라는 용어로 부른다. 우리가 new 연산자로 어떤 객체를 생성했을 때 그 객체는 빈이 아니다.
즉 스프링 컨테이너가 생성한 객체들을 '빈'이라고 한다.
스프링 필터랑 인터셉터의 차이점이 뭘까요
실행되는 시점에서 차이가 있다. 필터는 dispatcherServlet으로 요청이 가기전에 실행되고 인터셉터는 Controller로 요청이 가기전에 실행된다.
따라서 컨트롤러에 들어가기 전 작업을 처리하기 위해 사용하는 공통점이 있지만, 호출되는 시점에서 차이가 존재한다.
Entity란
Entity 클래스는 실제 데이터베이스의 테이블과 1:1로 매핑되는 클래스로 DB의 테이블내에 존재하는 컬럼만을 속성으로 가져야한다.
Setter를 무분별하게 사용하면 안되는 이유
엔티티를 작성할 때 Setter를 무분별하게 사용하면 객체(Entity)의 값을 변경할 수 있으므로 객체의 일관성을 보장할 수 없다.
DTO와 VO 차이점
VO는 DTO와 동일한 개념이지만 read only 속성을 갖는다. VO는 특정한 비즈니스 값을 담는 객체이고, DTO는 Layer간의 통신 용도로 오고가는 객체를 말한다.
Object에 대해서 설명해주세요
객체란, 소프트웨어 세계에 구현할 대상
클래스의 인스턴스 라고도 부른다. OOP 관점에서 클래스의 타입으로 선언되었을 때 객체라고 부른다.
객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
클래스
연관되어 있는 변수와 메서드의 집합
클래스란, 객체를 만들어 내기 위한 설계도 혹은 틀
인스턴스
객체를 소프트웨어에 실체화 하면 그것을 인스턴스 라고 부른다.
OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 인스턴스 라고 부른다.
객체는 클래스의 인스턴스이다.

인스턴스화 된다라는게 무슨의미인가여
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 한다.
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라고 한다.
String, StringBuffer, StringBuilder 차이점이 무엇인가요
첫번째 차이점은 String은 불변하다는 특징을 가지고 있어서 수정을 하지못하고 새로운 String 인스턴스가 생성되고 전에 있던 String은 GC에 의해 사라지게 된다. 그래서 좋은 성능을 기대하기는 힘들다. (String 불변, StringBuffer, StringBuilder 가변)
StringBuffer는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다는 점(thread-safe) 입니다. 참고로 String도 불변성을 가지기때문에 마찬가지로 멀티쓰레드 환경에서의 안정성(thread-safe)을 가지고 있습니다.
반대로 StringBuilder는 동기화를 지원하지 않기때문에 멀티쓰레드 환경에서 사용하는 것은 적합하지 않지만 동기화를 고려하지 않는 만큼 단일쓰레드에서의 성능은 StringBuffer 보다 뛰어납니다
프로세스란?
운영체제로부터 시스템 자원을 할당받는 작업의 단위
하나의 프로세스는 크게 코드영역(code), 데이터 영역(date), 스택 영역(stack), 힙 영역(heap) 4가지로 이루어져 있습니다.
스레드란?
한 프로세스 내에서 동작되는 여러 실행의 흐름, 프로세스 하나에 자원을 공유하면서 일련의 과정을 여러 개를 동시에 실행 시킬 수 있다.
멀티프로세스
장점 : 안정성이 높다 (독립된 구조기 때문에)
단점 : 여러 프로세스를 왔다갔다 하는 컨텍스트 스위칭으로 인한 성능저하
멀티쓰레드
장점 : 응답시간 단축, 자원소모 감소
단점 : 미묘한 시간차나 변수 공유함으로써 오류 발생 가능
MVC에 대해서 설명해주세요
MVC 패턴은 Model, View, Controller 이 3가지로 나뉘어 역할을 분할하여 처리한다.
역할을 나누어 처리하기 때문에 서로의 결합도가 낮아져서 좋은 코드가 되며 유지보수도 하기 편해진다.
JPA에서 Entity를 설계할때 주의점을 말해주세요
Entity에는 가급적 Setter를 사용하지 말 것
Entity가 영속성이 유지되는 도중 수정되면 그 값은 DB에 그대로 반영됩니다. 그런데 Setter를 열어두고 값을 변경하는 경우에는 변경 포인트가 많아 유지보수가 어려워 질 수 있습니다.
모든 연관관계는 지연로딩으로 설정한다
즉시로딩(EAGER)를 사용 할 경우, 어떤 SQL이 나갈지 추적하기 어렵다
컬렉션은 필드에서 바로 초기화하자
Entity는 최대한 순수하게 유지해야한다!!!
DTO를 사용하는 이유
순환참조를 예방할 수 있다.
JPA로 개발할 때, 양방향 참조를 사용했다면 순환참조를 조심해야한다.
엔티티 내부 구현을 캡슐화 할 수 있다.
DB Layer와 View Layer 사이의 역할을 분리 하기 위해서다
N+1 문제에 대해 짧게 설명해주세요
Lazy 로딩에 의해서 한번에 모든 정보를 안가져와서 발생하는 문제인데 폐치조인을 사용해서 해결할 수 있다.
SQL 1번으로 100명의 회원을 조회하였는데,한번 SQL을 실행해서 조회된 결과 수만큼 N번 SQL을 추가로 실행한다고 해서 N+1 문제라 한다.
각 회원마다 주문한 상품을 추가로 조회하기 위해 100번의 SQL을 추가로 실행하는 상황을 말한다.
생성자 injection을 사용한 이유
필드 인젝션은 점차 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는 필드주입은 사용하지 않는것이 좋다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양해야 한다.
 

생성자 인젝션은 생성자로 객체를 생성하는 시점에 필요한 빈을 주입한다. 그러므로 순환참조를 해결 할 수 있다. 필드를 final로 선언 가능하다. DI 컨테이너를 사용하지 않고도 테스트를 진행 할 수 있다.

 

자바 람다 관련 함수형 프로그래밍
함수형 프로그래밍은 명령형이 아닌 선언적 방식으로 구현되며 흐름 제어를 명시적으로 기술하지 않고 프로그램 로직이 표현된다는 것을 의미한다.
람다는 함수의 구조로 되어있고 -> 와 같이 화살표 형태의 기호를 이용해 매개변수를 함수 바디로 전달하는 형태
가비지컬렉션이란?
C/C++ 언어와 달리 자바는 개발자가 명시적으로 객체를 해제할 필요가 없습니다. 자바 언어의 큰 장점이기도 합니다. 사용하지 않는 객체는 메모리에서 삭제하는 작업을 Gargabe Collection(GC)라고 부르며 JVM에서 GC를 수행합니다.
자바 컬렉션 List, set, map에 대한 설명
List : 순서가 있는 데이터의 집합으로 데이터의 중복을 허용한다.
Set : 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않는다.
Map : 키, 값으로 이루어진 데이터의 집합으로, 순서는 유지되지 않으며 키의 중복을 허용하지 않으나 값의 중복은 허용한다.
스프링 자세하게 DI에 대한 설명, 생성자 injection이 좋은 이유
필드주입을 사용하게 되면 배터리 일체형 핸드폰과 같다고 볼 수 있다 반면에 setter와 생성자 주입은 분리형으로 볼 수 있어 조금 더 유연하다
테스트 코드에 대한 설명??
단위테스트를 사용하면 좋은점은 개발 초기에 문제를 발견할 수 있다.
ORM에 대한 설명
ORM이란 객체와 DB테이블이 매핑을 이루는 것을 말한다. 즉 객체가 테이블이 되도록 매핑 시켜주는 것을 말함
ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메서드)로서 데이터를 조작할 수 있습니다.
JPA 장점, 단점
JPA란 자바 ORM 기술에 대한 API 표준 명세를 의미한다.
Hibernate는 JPA라는 명세의 구현체이다.
장점
생산성 : SQL의 반복작업이 없어진다.
유지보수 : 테이블 컬럼 한개가 바뀌면 Mybatis에서는 관련 DAO의 파라미터, 결과 SQL등을 모두 확인하여 수정해주어야한다. JPA는 대신 해준다.
단점
성능 : 직접 SQL을 호출 하는 것보다 성능이 떨어 질 수 있다.
세밀함 : 복잡한 통계 분석 쿼리를 메서드 호출로 처리하기 힘들다. (이러한 문제를 보완하기 위해 JPA에서 JPQL을 지원한다
생성자 주입 사용시 장점
순환 참조 방지
순환 참조는 A -> B를 참조하면서, B -> A를 참조하는 경우 발생하는 문제
생성자 주입은 먼저 빈을 생성하지 않고 주입하려는 빈을 찾는다. 그래서 실행시 바로 순환참조 에러가 뜨면서 찾을 수 있다.
final 선언이 가능
생성자 주입 시, 의존성 주입이 클래스 인스턴스화 중에 시작되므로 final을 선언할 수 있다. 따라서 객체를 변경이 불가능하게 할 수 있다.
테스트 코드 작성 용이
스프링 컨테이너 도움 없이 테스트 코드를 더 편리하게 작성 가능
MVC 진행 방식
클라이언트로부터 요청이 들어오면 dispatcherServlet이 가장 먼저받는다.
HandlerMapping이 요청 URL과 매핑되는 Controller 검색 후 리턴
HandlerAdapter에서 알맞은 controller 처리요청
ViewResolver에서 controller가 리턴한 view 검색후 view를 클라이언트로 보냄

AOP
관점 지향 프로그래밍, 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화 하겠다는 것이다.
스프링 빈에만 AOP 적용 가능
프록시
프록시는 타겟을 감싸서 타겟의 요청을 대신 받아주는 랩핑 오브젝트이다.
프록시의 단어 자체로는 '대리인'이라는 의미를 내포하고 있음. 스프링 AOP에서의 프록시란 말그대로 대리하여 업무를 처리. 함수 호출자는 주요 업무가 아닌 보조 업무를 프록시에게 맡기고, 프록시는 내부적으로 이러한 보조 업무를 처리.
필터에 대한 동작 방식
Interceptor와 Filter는 Servlet 단위에서 실행된다. 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.

spring security
스프링 기반의 어플리케이션의 보안(인증과 권한)을 담당하는 프레임워크이다.
세션-쿠키 방식으로 인증한다.

jwt
JWT 방식은 확장성에 큰 강점을 가진다. 만약 세션을 사용하는 경우, 서버를 확장할 때마다 각 서버에 세션 정보를 저장하게 된다. 이렇게 될 경우, 특정 서버에서 로그인 인증을 받을 때 다른 서버에서는 로그인을 했는지 알 수 없다는 단점이 있다.
OAuth2
OAuth (OpenID Authentication) 란, 타사의 사이트에 대한 접근 권한을 얻고 그 권한을 이용하여 개발할 수 있도록 도와주는 프레임워크다. 구글, 카카오, 네이버 등과 같은 사이트에서 로그인을 하면 직접 구현한 사이트에서도 로그인 인증을 받을 수 있도록 되는 구조다.
OAuth2 로그인을 사용한다면 `UsernamePasswordAuthenticationFilter` 대신 `OAuth2LoginAuthenticationFilter` 가 호출되게 해야한다.
oauth는 세션대신 토큰을 사용하여 인증 진행 (토큰을 또 jwt 토큰으로 바꿔서 사용 많이함)

JPA, ORM 객체와 데이터베이스 차이 매꿔주는 이론 정확히 알기
ORM은 객체와 디비의 데이터를 자동으로 매핑해준다.
영속성 컨텍스트란, 영속성 컨텍스트가 있어서 장점
영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다. EntityManager는 영속성 컨텍스트에 Entity를 보관하고 관리
영속성 컨텍스트 장점
1차캐시 : 1차캐시에서 데이터를 먼저 찾고 없으면 DB에서 찾는다.
동일성 보장
쓰기 지연 : 트랜잭션을 커밋하기 직전까지 쿼리를 날리지 않고 영속성 컨텍스트에 보관한다.
변경 감지 : 스냅샷을 이용하여 영속성 컨텍스트에 저장된 엔티티는 변경이 일어나면 자동으로 데이터베이스 에서 수정된다.
지연 로딩 : 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 불러오는 방법
servlet dispacher
controller로 들어가기 전에 맨 앞에서 모든 요청을 받아서 해당하는 controller로 보내준다.
트랜잭션
어떤 일련의 작업들은 모두 에러 없이 끝나야 하며,
만약 중간에 에러가 발생 한다면, 에러 발생 이전 시점까지 작업되었던 내용은 모두 원상복구 되어야 합니다.
객체지향 관점에서 스프링 프레임워크를 바라봤을 때 장단점
스프링이 지향하는 목적 정의 : POJO 프로그래밍
POJO(Plain Old Java Object)는 말 그대로 간단한 자바 오브젝트를 사용하는 것을 말한다.
진정한 POJO란 객체 지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브텍트를 말한다.
스프링에 IOC/DI, AOP는 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 기술이다.































